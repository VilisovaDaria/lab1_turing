[ТЗ: Сортировка выбором массива чисел in-place. Ответ содержится в 130 - 136 ячейках]
T 56 K
GK [фиксация адреса подпрограммы]
[0]A 3 F [пролог: формирование кода инструкции возврата в акк.]
[1]T 60 @ [пролог:  запись инструкции возврата]
[2|loop1] T 30 F [обнуление акк.]
[3]A 11 F  [загрузка в акк. количества неотсортированных элементов <length>]
[4]S 64 @  [уменьшаем на 1 <c1>]
[5]T 11 F  [перезапись счетчика <length>]
[6]A 63 @  [загрузка в акк. константы 0 <c0>]
[7]U 6 F   [формируем счетчик i]
[8]S 11 F [уменьшаем значение на <length>]
[9]E 60 @  [if A>=0 завершение программы]
[10]T 30 F   [обнуление акк.]
[11]A 10 F  [загрузка в аккумулятор адреса 0-го элемента массива]
[12]U 0 F    [записываем значение в рабочую ячейку 0]
[13]U 1 F    [записываем значение в рабочую ячейку 1]
[14]A 62 @ [прибавляем код инструкции A 0 F]
[15]T 16 @  [запись сформированной инструкции в ячейку 16]
[16]A 0 F   [загрузка в аккумулятор ячейки N массива]
[17]T 2 F   [запись этого значения в рабочую ячейку 2, обнуление аккумулятора]
[18|loop2] T 30 F   [обнуление акк.]
[19]A 64 @ [увеличиваем на константу 1 <c1>]
[20]L 0 D  [сдвиг аккумулятора на 1 разряд влево]
[21]A 1 F   [загрузка адреса элемента N + i массива]
[22]U 1 F  [перезаписываем значение адреса]
[23]A 62 @ [прибавляем код инструкции A 0 F]
[24]T 25 @  [запись сформированной инструкции в ячейку 25]
[25]A 0 F   [помещаем в акк. N+i элемент массива]
[26]T 3 F   [записываем в 3 ячейку]
[27]A 6 F   [формируем второй счетчик для цикла loop2]
[28]A 64 @ [увеличиваем i на константу 1 <c1>]
[29]U 6 F   [перезаписываем значение i]
[30]S 11 F [уменьшаем на количество неотсортированных элементов <length>]
[31]E 44 @ [if A >= 0 выйти из цикла loop2, продолжить цикл loop1]
[32]T 30 F   [обнуление акк.]
[33]A 2 F   [поместили в акк. N элемент]
[34]S 3 F   [сравниваем с элементом N+i]
[35]E 18 @ [if N >= N+i,  берем следующий элемент в цикле loop2]
[36]T 30 F   [обнуление акк.]
[37]A 3 F   [считываем N+i элемент массива]
[38]T 2 F   [записываем в ячейку для N элемента]
[39]A 1 F   [считываем адрес N+i элемента]
[40]T 0 F   [записываем в ячейку для адреса N элемента]
[41]A 3 F   [помещаем в акк. N+i элемент]
[42]S 3 F   [очистили ячейку]
[43]E 18 @  [повтор действий цикла loop2]
[44|loop1]T 30 F   [обнуление акк.]
[45]A 2 F   [загрузка в акк. наибольшего элемента неотсортированной части массива полученного в цикле loop2]
[46]S 3 F   [сравниваем с последним элементом неотсортированной части массива]
[47]G 2 @ [если последний больше наибольшего, то продолжаем цикл loop1, так как перестановка элементов не требуется]
[48]T 30 F   [обнуление акк.]
[49]A 0 F   [помещаем в акк. адрес наибольшего элемента массива]
[50]A 61 @ [прибавляем код инструкции T 0 F]
[51]T 53 @  [запись сформированной инструкции в ячейку 53]
[52]A 3 F   [помещаем в акк. последний элемент массива]
[53]T 0 F   [записываем элемент на место наибольшего элемента]
[54]A 1 F   [помещаем в акк. адрес последнего элемента массива]
[55]A 61 @ [прибавляем код инструкции T 0 F]
[56]T 58 @  [запись сформированной инструкции в ячейку 58]
[57]A 2 F   [помещаем в акк. наибольший элемент массива]
[58]T 0 F   [записываем элемент на место последнего элемента]
[59]E 2 @ [повторяем все операции]
[60]E 0 F   [exit]
[61]T 0 F  [инструкция для записи в ячейки по адресу]
[62]A 0 F  [инструкция для чтения значения из ячейки по адресу]
[63]P 0 F  [const c0: 0]
[64]P 0 D  [const c1: 1]
GK [фиксация начального адреса тестовой программы]
[0] A 7 @ [адрес массива]
[1] T 10 F [запись адреса массива в ячейку 10, обнуление аккумулятора]
[2] A 8 @ [длина массива]
[3] T 11 F [запись длины массива в ячейку 11, обнуление аккумулятора]
[4] A 4 @  [\ вызов       ]
[5] G 56 F [/ подпрограммы]
[6] Z 0 F [останов]
[Адрес массива| 7] P 9 @ [адрес массива = <начало программы> + 9]
[Размер массива| 8] P 3 D [7]
[Массив| 9] P 1 F [2]
[10] P 6 D [13]
[11] P 3 F [6]
[12] P 8 D [17]
[13] P 2 D [5]
[14] P 2 F [4]
[15] P 41 D [83]
EZ PF                           
